---
Kotlin Coroutine
---

#### 目录

1. 启动协程的三种方式
2. 挂起函数
2. 协程的生命周期
2. Channel
2. Flow
2. select
2. 协程中的并发同步
2. 协程中的异常
3. 协程中的线程池

#### 启动协程

启动协程有三种方式，分别是 launch、runBlocking、async。

launch 不会阻塞当前程序的执行流程，也无法获取协程的执行结果。它有点像是生活中的射箭。

runBlocking 可以获取协程的执行结果，但这种方式会阻塞代码的执行流程，因此它一般用于测试用途，生产环境当中是不推荐使用的。

async，则是很多编程语言当中普遍存在的协程模式。它像是结合了 launch 和 runBlocking 两者的优点。它既不会阻塞当前的执行流程，还可以直接获取协程的执行结果。它有点像是生活中的钓鱼。

#### 挂起函数

挂起函数可以极大地简化异步编程，让我们能够以同步的方式写异步代码。相比 “回调地狱” 式的代码，挂起函数写出来的代码可读性更好、扩展性更好、维护性更好，也更难出错。

1. 要定义挂起函数，只需要加上 suspend 关键字。这个关键字会改变函数类型的。
2. 挂起函数拥有挂起和恢复的能力，因此对于同一行代码来说，"=" 左右两边的代码分别可以执行在不同的线程之上。
3. 挂起函数的本质，就是 Callback。在 Kotlin 中被称为 Continuation。而 Kotlin 编译器将 suspend 翻译成 Continuation 的过程，则是 CPS 转换。这里的 Continuation 是代表了 “程序继续运行下去需要执行的代码”、“接下来要执行的代码” 或者 “剩下的” 代码。

挂起函数，只能在协程当中被调用，或者是被其他挂起函数调用。但协程中的 block，本质上仍然是挂起函数。

所以我们可以认为，挂起和恢复是协程的一种底层能力；而挂起函数则是一种上层的表现形式。

#### 协程的生命周期

Job 是 launch 的返回值，Deferred 是 async 的返回值，而 Deferred 也是实现了 Job 的接口。

协程是有生命周期的，同时协程是结构化的。具体来说有以下几点：

1. Job，相当于协程的句柄，Job 与协程的关系，有点像 “遥控器与空调的关系”。
2. Job 在它的内部，维护了一系列的生命周期状态，它也对应着协程的生命周期状态。
3. 通过 Job，我们可以监测协程的状态，比如 isActive、isCancelled、isCompleted；另外，我们也可以一定程度的操控协程的状态，比如 start()、cancel()。
4. 除此之外，我们还可以通过 Job.invokeOnCompletion{ } 来监听协程执行完毕的事件；通过 Job.join() 这个挂起函数，我们可以挂起当前协程的执行流程，等到协程执行完毕以后，再恢复执行后面的代码。
5. 而对于 Deferred.await()，它的行为模式和 Job.join() 类似，只是它还会返回协程的执行结果。
6. 另外，协程是结构化的并发，这是它的第二大优势。通过分析 Job 的源码，我们发现，一个 Job 可以拥有多个 ChildJob；对应的，协程也可以拥有多个 “子协程”。
7. 结构化并发的最大优势在于，我们可以实现只控制 “父协程”，从而达到控制一堆子协程的目的。parentJob.join() 不仅仅只会等待它自身执行完毕，还会等待它内部的 job1、job2、job3 执行完毕，parentJon.cancel() 同理。

#### Channel

1. Channel 是一个管道，当我们想要用协程传递多个数据组成的流的话，就没办法用过挂起函数、async 来实现了，这时候 Channel 是一个不错的选择。
2. 我们可以通过 Channel() 这个顶层函数来创建 Channel 管道。在创建 Channel 的时候，有三个重要参数：capacity 代表了容量；onButterOverflow 代表容量满了以后的应对策略；onUndeliverdElement 则是一个异常回调。在某些场景下，比如 "发送方对于数据是否被接收方十分关心" 的情况下，可以注册这个回调。
3. Channel 有两个关键的方法：send()、receive()，前者用于发送管道数据，后者用户接收管道数据。但是，由于 Channel 是存在关闭状态的，如果我们直接使用 receive()，就会导致各种问题。因此，对于管道数据的接收方来说，我们应该尽可能的使用 for 循环、consumeEach{}。
4. Channel 是 "热" 的，这是因为不管有没有接收方，发送方都会工作。
5. Channel 其实是 SendChannel、ReceiveChannel 这两个接口的组合，我们也可以借助它的这个特点，实现 "对读取开放，对写入关闭" 的设计。

#### Flow

1. Flow 就是数据流，整个 Flow 的 API 设计，可以大致分为三个部分，上游的源头、中间操作符、下游终止操作符。
2. 对于上游源头来说，它主要负责：创建 Flow，并且产生数据。而创建 Flow，主要有三种方式：flow{}、flowOf()、asFlow()。
3. 对于中间操作符来说，它也可以分为几大类。第一类是从集合抄过来的操作符，比如 map、filter；第二类是生命周期回调，比如 onStart、onCompletion；第三类是功能性 API，比如说 flowOn 切换 Context、catch 捕获上游的异常。
4. 对于下游的终止操作符，也是分为三大类。首先，就是 collect 这个最基础的终止操作符；其次，就是从集合 API 抄过来的操作符。比如 fold、reduce；最后就是 Flow 转化成集合的 API，比如说 flow.toList()。

#### select

1. select 就是选择更快的结果。
2. 当 select 与 async、Channel 搭配以后，我们可以并发执行协程任务，以此大大提升程序的执行效率甚至用户体验，并且还可以改善程序的扩展性、灵活性。
3. 关于 select 的 API，我们完全不需要去刻意记忆，只需要在 Deferred、Channel 的 API 基础上加上 on 这个前缀即可。
4. 最后，我们还结合实战，分析了 select 与 async 产生太多并发协程的时候，还可以定义一个类似 fastest() 的方法，去统一取消剩余的协程任务。这样的做法，就可以大大节省计算资源，从而平衡性能与功耗。

#### 并发同步

Kotlin 协程解决并发的两大思路，分别是 Java 思路、协程思路。要注意，对于 Java 当中的同步手段，我们并不能直接照搬到 Kotlin 协程当中来，其中最大的问题，就是 synchronized 不支持挂起函数。

而对于协程并发手段，有四种：

1. 第一种手段，单线程并发。在 Java 世界里，并发往往意味着多线程，但在 Kotlin 协程当中，我们可以轻松实现单线程并发，这时候我们就不用担心多线程同步的问题了。
2. 第二种手段，Kotlin 官方提供的协程同步锁，Mutex，由于它的 lock 方法是挂起函数，所以它跟 JDK 当中的锁不一样，Mutex 是非阻塞的。需要注意的是，我们在使用 Mutex 的时候，应该使用 withLock{} 这个高阶函数，而不是直接使用 lock()、unlock()。
3. 第三种手段，Kotlin 官方提供的 Actor，这是一种普遍存在的并发模型。在目前的版本当中，Kotlin 的 Actor 只是 Channel 的简单封装，它的 API 会在未来的版本发生改变。
4. 第四种手段，借助函数式思维。我们之所以需要处理多线程同步问题，主要还是因为存在共享的可变状态。其实，共享可变状态，既不符合无副作用的特性，也不符合不变性的特性。当我们借助函数式编程思维，实现无副作用和不变性以后，并发代码也会随之变得安全。

#### 异常

在 Kotlin 协程当中，异常主要分为两大类，一类是协程取消异常（CancellationException），另一类是其他异常。为了处理这两大类问题，有 6 大准则需要知道。

1. 协程的取消需要内部的配合

2. 不要轻易打破协程的父子结构

   这一点，其实不仅仅只是针对协程的取消异常，而是要贯穿于整个协程的使用过程中。我们知道，协程的优势在于结构化并发，它的很多特性都是建立在这个特性之上的，如果我们无意中打破了它的父子结构，就会导致协程无法按照预期执行。

3. 捕获了 CancellationException 以后，要考虑是否应该重新抛出来

   在协程内部，协程是依赖于 CancellationException 来实现结构化取消的，有的时候我们出于某些目的需要捕获 CancellationException，但捕获完以后，我们还需要思考是否需要将其重新抛出来。

4. 不要使用 try-catch 直接包裹 launch、async

   考虑到协程代码的执行顺序与普通程序不一样，我们直接使用 try-catch 包裹 launch、async 是不会有任何效果的。

5. 灵活使用 SupervisorJob，控制异常传播的范围

   SupervisorJob 是一种特殊的 Job，它可以控制异常的传播范围。普通的 Job，它会因为子协程当中的异常而取消自身，而 SupervisorJob 则不会受到子协程异常的影响。在很多业务场景下，我们都不希望子协程影响父协程，所以 SupervisorJob 的应用范围也非常广。比如说 Android 当中的 viewModelScope，它就使用了 SupervisorJob，这样一来，我们的 App 就不会因为某个子协程的异常导致整个应用的功能出现紊乱。

6. 使用 CoroutineExceptionHandler 处理复杂结构的协程异常，它仅在顶层协程中起作用。传统的 try-catch 在协程当中并不能解决所有问题，尤其是在协程嵌套层级较深的情况下。Kotlin 官方为我们提供了 CoroutineExceptionHandler 作为补充，有了它，我们可以轻松捕获整个作用域内的所有异常。

#### 协程中的线程池
下面我们来直接观察Kotlin协程的线程池。
   fun test() {
        lifecycleScope.launch(Dispatchers.IO) { }
    }

指定协程运行的线程池我们知道要通过Dispatchers，有：

Main： 即UI线程
Default： 通常用于执行CPU密集型任务
IO： 通常用于执行会阻塞线程的任务，比如网络请求，文件读写等
