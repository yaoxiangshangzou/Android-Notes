---
设计模式口水话
---

#### 目录

1. 六大设计原则
2. 单例模式
3. 工厂模式
4. 建造者模式
5. 代理模式
6. 装饰器模式
7. 适配器模式
8. 观察者模式
9. 责任链模式

#### 六大设计原则
solid 稳定的 各个模式的英文首字母  
六大设计原则分别是单一职责原则、开闭原则、里式替换原则、接口隔离原则、依赖反转原则及迪米特原则。

1、单一职责原则（Single Responsibility Principle，简称SRP ）  

    核心思想：应该有且仅有一个原因引起类的变更
    问题描述：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。
    好处：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。
    需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。

2、里氏替换原则（Liskov Substitution Principle,简称LSP）  

    核心思想：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。
    通俗来讲：只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。
    好处：增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。
    需注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。

3、依赖倒置原则（Dependence Inversion Principle,简称DIP）  

    核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；
    说明：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。
    通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。
    问题描述：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。
    解决方案：将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。
    好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。

4、接口隔离原则（Interface Segregation Principle,简称ISP）  

    核心思想：类间的依赖关系应该建立在最小的接口上  
    通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。  
    问题描述：类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
    需注意：
    接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度
    提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情
    为依赖接口的类定制服务。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。

5、迪米特法则（Law of Demeter,简称LoD）  

    核心思想：类间解耦。  
    通俗来讲： 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。

6、开放封闭原则（Open Close Principle,简称OCP）

    核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化  
    通俗来讲： 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。


一句话概括:单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。



#### 单例模式

单例模式保证一个类仅有一个实例，并提供一个访问它的全剧访问点。它的实现有饿汉式、懒汉式、DCL、静态内部类和枚举。

单例模式的应用场景有避免资源访问冲突、表示业务概念上的全剧唯一类。

在 Android 中，常用的单例类有 LayoutInflater、LocalBroadcastManager 等。

#### 工厂模式

工厂模式可以细分为三种类型：简单工厂、工厂方法和抽象工厂。

当创建逻辑比较复杂时，就可以考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。何为创建逻辑毕竟复杂呢？主要有两种情况，第一种情况是类似规则配置解析的例子，代码中存在 if-else 分支判断，动态的根据不同的类型创建不同的对象。针对这种情况，我们就可以考虑使用工厂模式，将这一大块的 if-else 创建对象的代码抽离出来，放到工厂类中。还有一种情况是，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作，在这种情况下，我们也可以考虑使用工厂模式。

常见的工程模式有 DataFormat 类、String.valueOf 等等。

#### 构建者模式

构建者模式即 Builder 模式。如果一个类中有很多属性，为了避免构造函数的参数列表很长，影响代码的可读性和易用性，我们可以通过构造函数配合 setXxx() 方法来解决。不仅可以控制参数的必要性，还可以对参数进行合法性校验。

在 Android 中，最典型的应用莫过于 AlertDialog 了。

#### 代理模式

代理模式是指在不改变原始类的情况下，通过引入代理类来给原始类附加功能。代理可以分为静态代理和动态代理。

静态代理的实现比较简单，就是把实际的对象通过构造函数传给代理类，代理类可以在原有的基础上添加一些附加功能。动态代理不必像静态代理事先为每个原始类编写代理类，他可以在运行时动态的创建原始类的代理类，然后在系统中用代理类替换带原始类。在 Java 中的实现也比较简单，毕竟提供了InvocationHandler 来做，但是 Java 中的动态代理只能代理接口，如果想代理类就要使用 cglib 了。

在做插件化，Hook Activity 的生命周期时，就可以使用动态代理替换掉 ActivityThread 的 H 类的 handleMessage 方法。

#### 装饰器模式

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或接口。这其实有点静态代理的内味，但是代理模式一般附加的是跟原始类无关的功能，比如打点，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。

在 Java 中，典型的装饰器模式应用就是 Java 的 I/O 类库了。

#### 适配器模式

适配器模式就是用来做适配的，它将不兼容的接口转化为可兼容的接口，让原本由于接口不兼容而不能在一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。

适配器模式的应用场景有：封装有缺陷的接口设计、替换依赖的外部系统、兼容老版本接口、适配不同格式的数据。

在 Android 中最常见的适配器模式就是 RecyclerView 的数据适配器了，Java 中的 Arrays.asList 也可以看做一种数据适配器，将数组类型的数据转化为集合数据类型。

结合上面所讲的代理模式和装饰者模式，这三种模式都属于结构型模式，也都可称为 Wrapper 模型，也就是通过 Wrapper 类二次封装原始类。但这三种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同。代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。装饰器模式是对原始类功能进行增强，并且支持多个装饰器的嵌套使用。适配器模式是一种事后的补救策略，适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。

#### 观察者模式

观察者模式的表现形式是，在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动接收到通知。

生产者消费者模型如消息队列，一般都可以看成是观察者模式。在 Android 中，最常见的观察者模式应用就是广播了。

在 Java 中的 util 包下也有 Observable 和 Observer，不过这个 Observable 是一个类而不是一个接口，其次它的所有方法比如 addObserver、deleteObserver、setChanged、notifyObservers 等都是加锁的，notifyObservers 由于加锁可能存在两个问题，新添加的观察者没有收到通知和注销的观察者依旧收到了通知。

#### 责任链模式

责任链模式是指将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。在 GoF 的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。Android 中事件分发机制的用的就是这种形式。当然，也存在请求不会被终止传递的场景，而是所有处理器都会处理一遍，OkHttp 的拦截器链使用的就是这种形式。

